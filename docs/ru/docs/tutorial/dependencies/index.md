# Зависимости

**FastAPI** имеет очень мощную, но интуитивно понятную систему **<abbr title="also known as components, resources, providers, services, injectables">Внедрения зависимостей</abbr>**.

Она спроектирована таким образом, чтобы быть очень простой в использовании, и чтобы любой разработчик мог легко интегрировать другие компоненты с **FastAPI**.

## Что такое "Внедрение зависимостей"

**"Внедрение зависимостей"** в программировании означает, что в коде (в данном случае в *функции операции пути*) есть способ объявить вещи, которые необходимы ему для работы и использования: "зависимости".

А затем эта система (в данном случае **FastAPI**) позаботится о том, чтобы сделать все необходимое для обеспечения вашего кода этими необходимыми зависимостями ("внедрить" зависимости).

Это очень полезно когда необходимо:

* Иметь общую логику (один и тот же код логики снова и снова).
* Совместное использование соединений с базами данных.
* Обеспечивать безопасность, аутентификацию, ролевые требования и т.д.
* И многое другое...

И все это при минимальном повторении кода.

## Первый шаг

Рассмотрим очень простой пример. Он будет настолько прост, что пока не очень полезен. Но таким образом мы можем сосредоточиться на том, как работает система **Внедрения Зависимостей**.

### Создать зависимость

Сначала остановимся на зависимости.

Это просто функция, которая может принимать все те же параметры, что и *функция операции пути*:

=== "Python 3.10+"

    ```Python hl_lines="8-9"
    {!> ../../../docs_src/dependencies/tutorial001_an_py310.py!}
    ```

=== "Python 3.9+"

    ```Python hl_lines="8-11"
    {!> ../../../docs_src/dependencies/tutorial001_an_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="9-12"
    {!> ../../../docs_src/dependencies/tutorial001_an.py!}
    ```

=== "Python 3.10+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="6-7"
    {!> ../../../docs_src/dependencies/tutorial001_py310.py!}
    ```

=== "Python 3.6+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="8-11"
    {!> ../../../docs_src/dependencies/tutorial001.py!}
    ```

И это все.

**2 строки**.

И он имеет ту же форму и структуру, что и все ваши *функции операции пути*.

Можно представить это как *функцию операции пути* без "декоратора" (без `@app.get("/some-path")`).

И она может вернуть все, что вы пожелаете.

В данном случае эта зависимость ожидает:

* Необязательный параметр запроса `q`, представляющий собой `str`.
* Необязательный параметр запроса `skip`, который является `int` и по умолчанию равен `0`.
* Необязательный параметр запроса `limit`, который представляет собой `int` и по умолчанию равен `100`.

А затем просто возвращает `dict`, содержащий эти значения.

!!! info "Информация"
    Поддержка `Annotated` была добавлена в FastAPI начиная с версии 0.95.0 (и с этой версии рекомендуется использовать этот подход).

    Если вы используете более старую версию, вы столкнётесь с ошибками при попытке использовать `Annotated`.

    Убедитесь, что вы [обновили версию FastAPI](../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} как минимум до 0.95.1 перед тем, как использовать `Annotated`.

### Импорт `Depends`

=== "Python 3.10+"

    ```Python hl_lines="3"
    {!> ../../../docs_src/dependencies/tutorial001_an_py310.py!}
    ```

=== "Python 3.9+"

    ```Python hl_lines="3"
    {!> ../../../docs_src/dependencies/tutorial001_an_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="3"
    {!> ../../../docs_src/dependencies/tutorial001_an.py!}
    ```

=== "Python 3.10+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="1"
    {!> ../../../docs_src/dependencies/tutorial001_py310.py!}
    ```

=== "Python 3.6+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="3"
    {!> ../../../docs_src/dependencies/tutorial001.py!}
    ```

### Объявить зависимость

Точно так же, как вы используете `Body`, `Query` и т.д. с параметрами *функции операции пути*, используйте `Depends` с новым параметром:

=== "Python 3.10+"

    ```Python hl_lines="13  18"
    {!> ../../../docs_src/dependencies/tutorial001_an_py310.py!}
    ```

=== "Python 3.9+"

    ```Python hl_lines="15  20"
    {!> ../../../docs_src/dependencies/tutorial001_an_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="16  21"
    {!> ../../../docs_src/dependencies/tutorial001_an.py!}
    ```

=== "Python 3.10+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="11  16"
    {!> ../../../docs_src/dependencies/tutorial001_py310.py!}
    ```

=== "Python 3.6+ без Annotated"

    !!! tip "Подсказка"
        Рекомендуется использовать версию с `Annotated` если возможно.

    ```Python hl_lines="15  20"
    {!> ../../../docs_src/dependencies/tutorial001.py!}
    ```

Хотя вы используете `Depends` в параметрах функции так же, как и `Body`, `Query` и т.д., `Depends` работает несколько иначе.

Вы передаете `Depends` только один параметр.

Этот параметр должен быть чем-то вроде функции.

Вы **не вызываете его** напрямую (не добавляете скобки в конце), а просто передаете его в качестве параметра в `Depends()`.

И эта функция принимает параметры точно так же, как и *функции операции пути*.

!!! tip "Подсказка"
    О том, какие еще "вещи", кроме функций, можно использовать в качестве зависимостей, будет рассказано в следующей главе.

Каждый раз, когда поступает новый запрос, **FastAPI** позаботится об этом:

* Вызов своей зависимой функции с правильными параметрами.
* Получение результата от своей функции.
* Присвоить этот результат параметру в вашей *функции операции пути*.

```mermaid
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

Таким образом, вы один раз пишете общий код, а **FastAPI** заботится о его вызове для ваших *функций опрации пути*.

!!! check "Заметка"
    Обратите внимание, что не нужно создавать специальный класс и передавать его куда-то в **FastAPI** для "регистрации" или чего-то подобного.

    Вы просто передаете его в `Depends`, а **FastAPI** знает, как сделать все остальное.

## Поделиться `Annotated` зависимостями

В приведенных примерах вы видите, что в них присутствует небольшое количество **дублирование кода**.

Когда требуется использовать зависимость `common_parameters()`, необходимо записать весь параметр с аннотацией типа и `Depends()`:

```Python
commons: Annotated[dict, Depends(common_parameters)]
```

Но поскольку мы используем `Annotated`, мы можем хранить это `Annotated` значение в переменной и использовать его в нескольких местах:

=== "Python 3.10+"

    ```Python hl_lines="12  16  21"
    {!> ../../../docs_src/dependencies/tutorial001_02_an_py310.py!}
    ```

=== "Python 3.9+"

    ```Python hl_lines="14  18  23"
    {!> ../../../docs_src/dependencies/tutorial001_02_an_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="15  19  24"
    {!> ../../../docs_src/dependencies/tutorial001_02_an.py!}
    ```

!!! tip "Подсказка"
    Это стандартный Python, так называемый "псевдоним типа", который на самом деле не является специфичным для **FastAPI**.

    Но поскольку **FastAPI** основан на стандартах Python, включая `Annotated`, вы можете использовать этот трюк в своем коде. 😎

Зависимости продолжат работать, как и ожидалось, и **самая лучшая часть** заключается в том, что **информация о типе будет сохранена**, что означает, что ваш редактор сможет продолжать предоставлять вам **автодополнение**, **подсвечивание ошибок** и т.д. То же самое касается и других инструментов, таких как `mypy`.

Это будет особенно полезно при использовании его в **большой кодовой базе**, где **одни и те же зависимости** используются снова и снова во **многих *операциях пути***.

## Синхронность или асинхронность

Поскольку зависимости также будут вызываться **FastAPI** (так же, как и ваши *функции опираций путей*), при определении функций действуют те же правила.

Вы можете использовать `async def` или обычный `def`.

Причем можно объявлять зависимости с помощью `async def` внутри обычных `def` *функций опираций путей*, или `def` зависимости внутри `async def` *функций опираций путей* и т.д.

Это не имеет значения. **FastAPI** сам знает, что делать.

!!! note "Технические детали"
    Если вы не знаете, посмотрите раздел [Конкурентность и async / await](../../async.md){.internal-link target=_blank} в документации.

## Интеграция с OpenAPI

Все декларации запросов, валидации и требования ваших зависимостей (и подзависимостей) будут интегрированы в одну схему OpenAPI.

Таким образом, интерактивная документация будет содержать всю информацию и из этих зависимостей:

<img src="/img/tutorial/dependencies/image01.png">

## Простое использование

Если посмотреть, то объявляются *функции операции путей*, которые используются при совпадении *пути* и *операции*, а затем **FastAPI** заботится о вызове функции с нужными параметрами, извлекая данные из запроса.

Фактически все (или большинство) веб-фреймворков работают подобным образом.

Вы никогда не вызываете эти функции напрямую. Они вызываются вашим фреймворком (в данном случае **FastAPI**).

С помощью системы Dependency Injection вы также можете сообщить **FastAPI**, что ваша *функция операции пути* также "зависит" от чего-то другого, что должно быть выполнено перед вашей *функцией операции пути* , и **FastAPI** позаботится о ее выполнении и "внедрении" результатов.

Другими распространенными терминами, обозначающими эту же идею "внедрения зависимостей", являются:

* ресурсы
* провайдеры
* сервисы
* компоненты

## **FastAPI** плагины

Интеграции и "плагины" могут быть построены с использованием системы **внедрения зависимостей**. Но на самом деле **не нужно создавать "плагины"**, так как с помощью зависимостей можно объявить бесконечное число интеграций и взаимодействий, которые становятся доступными для ваших *функций операции путей*.

А зависимости могут быть созданы очень простым и интуитивно понятным способом, позволяющим просто импортировать нужные пакеты Python и интегрировать их с функциями API буквально в паре строк кода.

Примеры этого вы увидите в следующих главах, посвященных реляционным и NoSQL базам данных, безопасности и т.д.

## **FastAPI** совместимость

Простота системы внедрения зависимостей делает **FastAPI** совместимым со следующими системами:

* все реляционные базы данных
* базы данных NoSQL
* внешние пакеты
* внешние API
* системы аутентификации и авторизации
* системы мониторинга использования API
* системы инъекции данных в ответ
* и т.д.

## Простота и мощность

Хотя система иерархического внедрения зависимостей очень проста в определении и использовании, она, тем не менее, очень мощная.

Вы можете определять зависимости, которые, в свою очередь, сами могут определять зависимости.

В итоге строится иерархическое дерево зависимостей, а система **внедрения зависимостей** берет на себя решение всех этих зависимостей (и их подзависимостей) и предоставление (инжектирование) результатов на каждом шаге за вас.

Например, допустим, у вас есть 4 конечные точки API (*операций пути*):

* `/items/public/`
* `/items/private/`
* `/users/{user_id}/activate`
* `/items/pro/`

для каждого из них можно добавить свои требования к разрешениям просто с помощью зависимостей и подзависимостей:

```mermaid
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

## Интеграция с **OpenAPI**

Все эти зависимости, декларируя свои требования, также добавляют параметры, валидации и т.д. к вашим *операциям путей*.

**FastAPI** позаботится о том, чтобы добавить все это в схему OpenAPI, чтобы это отображалось в интерактивных системах документации.
